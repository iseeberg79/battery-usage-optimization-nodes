<script type="text/javascript">
    RED.nodes.registerType('@iseeberg79/PrepareForecastData', {
        category: 'function',
        color: '#a6bbcf',
        defaults: {
            name: {
                value: ""
            },
            exportPrice: {
                value: 0.079,
                validate: RED.validators.number()
            },
            timeInterval: {
                value: "1h"
            }
        },
        inputs: 1,
        outputs: 1,
        icon: "file.png",
        label: function() {
            return this.name || "Prepare Forecast Data";
        }
    });
</script>

<script type="text/x-red" data-template-name="@iseeberg79/PrepareForecastData">
    <div class="form-row">
        <label for="node-input-name">Name</label>
        <input type="text" id="node-input-name" placeholder="Name" class="input-typed"/>
    </div>
    <div class="form-row">
        <label for="node-input-exportPrice">Export Price (€/kWh)</label>
        <input type="text" id="node-input-exportPrice" placeholder="0.079" class="input-typed"/>
    </div>
    <div class="form-row">
        <label for="node-input-timeInterval">Time Interval</label>
        <select id="node-input-timeInterval" class="input-typed">
            <option value="1h">1 hour (60 minutes)</option>
            <option value="15m">15 minutes</option>
        </select>
    </div>
</script>

<script type="text/x-red" data-help-name="@iseeberg79/PrepareForecastData">
    <p>Dieser Node bereitet Forecast-Daten für den EstimateBatterymode Node vor. Er konsolidiert die drei Function Nodes aus dem ursprünglichen Flow.</p>

    <h3>Funktionen:</h3>
    <ol>
        <li><b>15min → Stundenwerte:</b> Konvertiert 15-Minuten-Preisdaten in stündliche Durchschnittswerte</li>
        <li><b>PV-Forecasts kombinieren:</b> Kombiniert zwei PV-Forecast-Arrays (z.B. zwei Dächer/Arrays)</li>
        <li><b>Daten transformieren:</b> Transformiert alle Daten in das Format für EstimateBatterymode</li>
    </ol>

    <h3>Konfiguration:</h3>
    <ul>
        <li><b>Export Price (€/kWh):</b> - Einspeisevergütung (Standard: 0.079)</li>
        <li><b>Time Interval:</b> - Zeitintervall für die Berechnung (1h oder 15m)</li>
    </ul>

    <h3>Eingaben:</h3>
    <ul>
        <li><b>msg.input.priceData15</b> - Array mit 15-Minuten-Preisdaten (wird zu Stundenwerten konvertiert wenn timeInterval = "1h")</li>
        <li><b>msg.input.priceData</b> - Alternativ: Array mit bereits stündlichen Preisdaten</li>
        <li><b>msg.pvforecast1</b> - Erster PV-Forecast (optional, wird kombiniert wenn pvforecast2 existiert)</li>
        <li><b>msg.pvforecast2</b> - Zweiter PV-Forecast (optional)</li>
        <li><b>msg.input.pvforecast</b> - Alternativ: Bereits kombinierter PV-Forecast</li>
        <li><b>msg.input.household</b> - Array mit Haushaltsverbrauchsprognose</li>
        <li><b>msg.input.soc</b> - Aktueller Batterie-Ladestand (State of Charge)</li>
        <li><b>msg.timezone</b> - Optional: UTC-Offset in Minuten für Consumption Forecast (Standard: 0 = UTC). Beispiel: -60 für CET (Winter), -120 für CEST (Sommer)</li>
        <li><b>msg.debug</b> - Optional: Aktiviert erweiterte Debug-Ausgaben (Boolean)</li>
    </ul>

    <h3>Ausgaben:</h3>
    <ul>
        <li><b>msg.payload.priceData</b> - Transformierte Preisdaten im EstimateBatterymode-Format</li>
        <li><b>msg.payload.productionForecast</b> - Transformierte PV-Produktionsprognose</li>
        <li><b>msg.payload.consumptionForecast</b> - Transformierte Verbrauchsprognose</li>
        <li><b>msg.payload.soc</b> - State of Charge</li>
    </ul>

    <h3>Datenformate:</h3>

    <h4>Input Preisdaten (15min):</h4>
    <pre>
[
    {"start": "2025-02-15T00:00:00Z", "value": 0.3123},
    {"start": "2025-02-15T00:15:00Z", "value": 0.3145},
    ...
]
    </pre>

    <h4>Input PV-Forecast:</h4>
    <pre>
[
    {
        "pv_estimate": 0.5,
        "pv_estimate10": 0.3,
        "pv_estimate90": 0.7,
        "period_end": "2025-02-15T01:00:00Z",
        "period": "PT30M"
    },
    ...
]
    </pre>

    <h4>Input Household Consumption:</h4>
    <pre>[1.5, 1.2, 0.8, 0.9, ...]</pre>

    <h4>Output Format (für EstimateBatterymode):</h4>
    <pre>
{
    "priceData": [
        {
            "start": "2025-02-15T00:00:00Z",
            "value": 0.3123,
            "importPrice": 0.3123,
            "exportPrice": 0.079
        },
        ...
    ],
    "productionForecast": [
        {"start": "2025-02-15T01:00:00Z", "value": 0.5},
        ...
    ],
    "consumptionForecast": [
        {"start": "2025-02-15T00:00:00Z", "value": 1.5},
        ...
    ],
    "soc": 45
}
    </pre>

    <h3>Hinweise:</h3>
    <ul>
        <li>Der Node kombiniert die Logik von drei Function Nodes in einem</li>
        <li>15-Minuten-Preisdaten werden automatisch zu Stundenmittelwerten konvertiert (wenn timeInterval = "1h")</li>
        <li>Zwei PV-Forecasts werden automatisch kombiniert wenn beide vorhanden sind</li>
        <li>Der Output ist direkt kompatibel mit dem EstimateBatterymode Node</li>
        <li>Intern wird noch mit 1h-Slots gerechnet - eine zukünftige Version könnte auch 15m-Slots unterstützen</li>
        <li><b>Timezone Handling:</b>
            <ul>
                <li>Alle eingehenden Zeitstempel (ISO-Strings, Unix-Timestamps) werden automatisch zu UTC konvertiert</li>
                <li>Price Data: Timestamps werden normalisiert (ISO-String, Unix timestamp in Sekunden/Millisekunden werden alle akzeptiert)</li>
                <li>PV Forecast: <code>period_end</code> wird automatisch zu <code>start</code> konvertiert basierend auf <code>period</code></li>
                <li>Consumption Forecast: Startet bei 00:00 UTC (Standard) oder bei <code>msg.timezone</code> Offset</li>
                <li>Für deutsche Zeitzone (CET/CEST): <code>msg.timezone = -60</code> (Winter) oder <code>-120</code> (Sommer)</li>
            </ul>
        </li>
    </ul>
</script>
